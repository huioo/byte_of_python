# 运算符与表达式

"""
下面是一个简单的表达式，表达式由运算符与操作数构成。
运算符是一些可以用+号或其他关键词符号替代的功能。
运算符会对相关数据进行运算，这些被运算的数据称为操作数。在下例中，2和3即为操作数。
"""
2+3


# 运算符
"""
下面简明地列出了常用的运算符：

+ (加)
    将两对象相加
    3 + 5 得 8. 'a' + 'b' 得 'ab'.

- (减)
    将一个数减去另一个数，若减号左边没有数字，则默认作左边为零。
    -5.2 为一个负数，而 50 - 24 则等于 26。

* (乘)
    得到两个数相乘的值，或者将一个字符串重复若干次。
    2 * 3 得到 6. 'la' * 3 得到 'lalala'.

** (乘方)
    返回 x 的 y 次幂
    3 ** 4 得到 81 (i.e. 3 * 3 * 3 * 3)

/ (除)
    x 除以 y
    13 / 3 得到 4.333333333333333

// (除且取整)
    x 除以 y 并返回小于商的最大整数，注意，如果操作数之一为浮点数，则返回值必为浮点数。
    13 // 3 得到 4
    -13 // 3 得到 -5
    9//1.81 得到 4.0

% (取模)
    返回作除法之后的余数。
    13 % 3 得到 1. 25.5 % 2.25 得到 0.75.
    -13 % 3 得到 2. -25.5 % 2.25 得到 1.5.

<< (左移)
    将数字位向左移动指定的位数。每个数字在内存中用位或二进制数（如 0 和 1 ）表示。
    2 << 2 得到 8. 2 在二进制中用 10 表示。
    将 10 向左移两位得到 1000 ，二进制 1000 表示十进制的 8 。

>> （右移）
    将数字按位向右移动指定的位数。
    11 >> 1 得到 5 。
    11 的二进制表示为 1011 ，将其右移一位后，得到 101也就是十进制的 5 。

& （按位与）
    数字的按位与
    5 & 3 得到 1。 二进制表示101&011，得到001

| （按位或）
    数字的按位或
    5 | 3 得到 7。 二进制表示101|011，得到111

^ （按位异或）
    数字的按位异或
    5 ^ 3 得到 6。 二进制表示101^011，得到110

~ （按位取反）
    x 按位取反是 -(x+1)
    ~5 得到 -6。更多细节请参阅 http://stackoverflow.com/a/11810203

< （小于）
    返回 x 是否小于 y 。所有的比较运动算符返回 True 或 False。 注意这些名字的大小写。
    5 < 3 得到 False ，而 3 < 5 得到 True。
    比较还可以任意链接： 3 < 5 < 7 得到 True。

> （大于）
    返回 x 是否大于 y
    5 > 3 返回 True。如果两个操作数都是数字，则首先要做的是将它们转换为相同的类型。否则，它总是返回 False。

<= （小于或等于）
    返回 x 是否小于或等于 y
    x = 3; y = 6; x <= y 返回 True

>= （大于或等于）
    返回 x 是否大于或等于 y
    x = 4; y = 3; x >= 3 返回 True

== （等于）
    比较一下对象是否相等
    x = 2; y = 2; x == y 返回 True
    x = 'str'; y = 'stR'; x == y 返回 False
    x = 'str'; y = 'str'; x == y 返回 True

!= （不等于）
    比较一下对象是否不相等
    x = 2; y = 3; x != y 返回 True

not （布尔非）
    如果 x 为 True，它会返回 False。如果 x 为 False，它会返回 True。
    x = True; not x 返回 False.

and （布尔与）
    如果 x 为 False ， x and y 返回 False 。否则，返回 y 的值
    由于 x 为 False ， x = False; y = True; x and y 返回 False 。在这种情况下， Python 不会计算 y ，因为它知道 '与' 表达式的左边为 False ，这就意味着整个表达式必定是 False。这就是所谓的短路计算。

or (（布尔或）
    如果 x 为 True，它会返回真，否则返回 y 的值
    x = True; y = False; x or y 返回 True。这里也用到了短路计算。

"""


# 数学运算和赋值的快捷方式
a = 2
a = a * 3   # 简写为 a*=3 ; 变量 = 变量 运算符 表达式 ——> 变量 运算符= 表达式


# 计算顺序
"""
下表给出了 Python 的优先级表，从最低优先级（最小约束）到做高优先级（最大约束）。
这就意味着在给定的表达式中， Python 会首先计算表中较低的运算符和表达式，然后计算表中较高的运算符和表达式。

为了完整起见，下表出自 Python 参考手册。
为了明确地指定优先级，最好使用括号适当地对运算符和操作数进行分组。
有关详细信息，请参阅 改变计算顺序。

    lambda ：Lambda 表达式
    if - else ：条件表达式
    or ：布尔或
    and ：布尔与
    not x :：布尔非
    in, not in, is, is not, <, <=, >, >=, !=, == ：比较，包括成员资格测试和身份测试
    | ：按位或
    ^ ：按位异或
    & ：按位与
    <<, >> ：移位
    +, - ：加减法
    *, /, //, % ：乘除法，取整和取余
    +x, -x, ~x ：正负号，按位非
    ** ：求幂
    x[index], x[index:index], x(arguments...), x.attribute ：订阅，切片，调用，属性引用
    (expressions...), [expressions...], {key: value...}, {expressions...} ： 绑定或者元组显示，列表显示，字典显示，设置显示

"""


# 改变计算顺序
"""
使用括号，使表达式更加具有可读性。合理使用，不要有冗余的括号。
例如： 2 + (3 * 4) 显然比 2 + 3 * 4 更容易理解，因为后者需要运算符优先级的知识。

使用括号还有另外一个优势——它能帮助我们改变计算的顺序。
例如，如果你想在一个表达式中先算加法后算乘法，那么你可以写成 (2 + 3) * 4 。
"""


# 关联性
# 一般而言，操作符从左到右进行关联。这意味着具有相同优先级的操作符按照从左到右的方式进行计算。
# 例如， 2 + 3 + 4 计算顺序为 (2 + 3) + 4 。


# 表达式
length = 5
breadth = 2

area = length * breadth
print('Area is', area)
print('Perimeter is', 2 * (length + breadth))
# 变量length和breadth保存了矩形的长宽，length * breadth的结果保存在变量area中，然后print打印结果。
